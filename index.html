<!DOCTYPE html>
<html lang="en" manifest="/manifest.appcache">
<head>
    <meta charset="utf-8">
	<meta name="description" content="COVID-19 tracking data">
	<meta name="author" content="Evan O'Keeffe NYU">
    <!--
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
    crossorigin=""/>
   
    <script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
   
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
    integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
    crossorigin=""></script>

    <script src='//api.tiles.mapbox.com/mapbox.js/plugins/leaflet-omnivore/v0.3.1/leaflet-omnivore.min.js'></script>
    -->
   
    <link rel="apple-touch-icon" sizes="180x180" href="./favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon/favicon-16x16.png">
    <link rel="manifest" href="./favicon/site.webmanifest">
   
    <link rel="stylesheet" href="./css/leaflet.css"/>
   
    <script src="./libs/jquery/3.5.1/jquery.min.js"></script>
   
    <!-- Make sure you put this AFTER Leaflet's CSS -->
    <script src="./libs/leaflet.js"></script>
   
    <!-- kml/z library loader -->
    <script src='./libs/leaflet-omnivore.min.js'></script>
   
    <!-- Search box and functionality libraries -->
    <script src='./libs/fuse.min.js'></script>
    <script src="./libs/leaflet-search.min.js"></script>
    <link rel="stylesheet" href="./css/leaflet-search.min.css" />
    
    <script src='./libs/leaflet.fusesearch.js'></script>    
    <link rel="stylesheet" href="./css/leaflet.fusesearch.css"/>
    
    <!-- For overlay menu tree selection -->
    <link rel="stylesheet" href="./css/L.Control.Layers.Tree.css" crossorigin=""/>
    <script src="./libs/L.Control.Layers.Tree.js"></script>
    
    <!-- SQL reading dependencies -->
    <script src='./libs/sql-wasm.js'></script>
    
    <style>
        .info {
            padding: 6px 8px;
            font: 14px/16px Arial, Helvetica, sans-serif;
            background: white;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 5px;
        }
        .info h4 {
            margin: 0 0 5px;
            color: #777;
        }
    </style>
    
    <script>
        var db = null;
        var db_content = null;
        var db_ready = false;
        var xhr = new XMLHttpRequest();
        
        config = {
            locateFile: filename => `./libs/${filename}`
        }
        
        xhr.open('GET', './data/geodata.sqlite', true);
        xhr.responseType = 'arraybuffer';

        xhr.onload = function(e) {
            db_content = new Uint8Array(this.response);
            
            console.log("database downloaded");
        };
        xhr.send();
        
        initSqlJs(config).then(function(SQL){
          //Create the database
          db = new SQL.Database(db_content);
          console.log("database ready");
          db_ready = true;
        });
    </script>
    
    <style>
        body {
            padding: 0;
            margin: 0;
        }
        html, body, #mapid {
            height: 100%;
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="mapid"></div>
    
    <!--
    <input id='search' class='search-ui' placeholder='Enter Data Name' />
    <input id='search_country' class='search-ui' placeholder='Enter Country Name' />
    -->
    
    <script>
        var info = null;
        var layer = null;
        var geojson_layer = null;
        
        var mymap = L.map('mapid').setView([40.7385 ,  -73.9711], 13);
        
        var osm = L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}', {
            attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
            maxZoom: 22,
            id: 'mapbox/streets-v11',
            tileSize: 512,
            zoomOffset: -1,
            accessToken: 'pk.eyJ1IjoiZXZhbm9rIiwiYSI6ImNra3FzNHJmdjM4d28yb3F0YnRiN3owaG0ifQ.1STNlFlEdByWEJkvPI2qrQ'
        });
        osm.addTo(mymap);
        
        var searchCtrl = null;
        var search_categories = [
                'properties.name',
			    'properties.description',
			    'properties.has_mask',
			    'properties.month',
			    'properties.year',
			    'properties.day',
			    'properties.state_district',
			    'properties.gender',
			    'properties.number_of_people',
			    'properties.country',
			    'properties.username',
		];
		
		// Object to store category layers
        var overlays = {};
        var categories = new Set();
        var ctl = null;
		//var controlLayers = L.control.layers().addTo(mymap);
		
		var options = {
                position: 'topleft',
                title: 'Search',
                placeholder: 'name,description,has_mask,month,year,gender,number_of_people,state_district',
                maxResultLength: 15,
                threshold: 0.5,
                showInvisibleFeatures: true,
                showResultFct: function(feature, container) {
                    props = feature.properties;
                    var name = L.DomUtil.create('b', null, container);
                    name.innerHTML = props.name;
                    
                    container.appendChild(L.DomUtil.create('br', null, container));
                    
                    var cat = props.name ? props.country : props.has_mask;
                    var information = '' + cat + ', ' + props.state_district;
                    container.appendChild(document.createTextNode(information));
                }
        };
        
        createInfoBox();
        
        function createInfoBox(){
            info = L.control({position:'bottomleft'});
            info.onAdd = function (map) {
                this._div = L.DomUtil.create('div', 'info left'); // create a div with a class "info"
                this.update();
                return this._div;
            };
            info.update = function (props) {
                if(props==null){this._div.innerHTML = ""; return;}
                this._div.innerHTML = "";
                this._div.innerHTML += props.properties.name + "<br>";
                this._div.innerHTML += props.properties.username + "<br>";
                this._div.innerHTML += props.geometry.coordinates[0] + "<br>";
                this._div.innerHTML += props.properties.state_district + "<br>";
                this._div.innerHTML += props.properties.country + "<br>";
                this._div.innerHTML += "Number of people:"+props.properties.number_of_people + "<br>";
                this._div.innerHTML += "Has mask:"+props.properties.has_mask + "<br>";
                this._div.innerHTML += "Full description:"+props.properties.description + "<br>";
            };
            info.addTo(mymap);
        };
        
        function getColor(d) {return '#800026';}
        
        function style(feature) {
            return {
                fillColor: getColor(feature.properties.has_mask),
                weight: 5,
                opacity: 1,
                color: 'red',
                fillOpacity: 0.7
            };
        }
        
        var customLayer = L.geoJson(null, {
            onEachFeature: function(feature, layer) {
                feature.layer = layer;
            }
        });
        
        function sleep(ms) {
          return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        const reverseDateRepresentation = date => {
          let parts = date.split('-');
          return `${parts[2]}-${parts[1]}-${parts[0]}`;
        };
        
        async function getFiles(){
            var url = "https://api.github.com/search/code?q=extension:kml+repo:eokeeffe/NYU-COVID-Data-Viewer";
            var start_url = "http://www.evoflighttech.com/NYU-COVID-Data-Viewer/";
            var sorted_filenames = {};
            var orderedDates = {};
            var filenames = [];
            
            $.getJSON( url ).done(function( data ) {
                
                data.items.forEach(function(element){
                    //console.log(element);
                    var date = element.name.split(".")[0].replace(/_/g,"/");
                    var path = element.path;
                    //console.log(date,path);
                    sorted_filenames[date] = {relative:path,full:path+start_url };
                });
                
                Object.keys(sorted_filenames).sort(function(a, b) {
                  return a.split('/').reverse().join('').localeCompare(b.split('/').reverse().join(''));
                }).forEach(function(key) {
                  orderedDates[key] = sorted_filenames[key];
                });
                console.log(orderedDates);
                return orderedDates;
           });
        };
        
        async function main(){
            //need to wait for X seconds to get the database downloaded
            await sleep(4000);
            console.log("wait complete for DB");
            
            //var date_files = await getFiles();
            //console.log("result= ", await date_files);
            
            loadData("./Data/12_01_2021.kml");
        }
        
        function simpleReverseGeocoding(longitude, latitude) {
            var scale = Math.pow(Math.cos(latitude * Math.PI / 180), 2);
            var query = `
                    SELECT * FROM everything WHERE id IN ( 
                        SELECT feature_id 
                        FROM coordinates 
                        WHERE latitude BETWEEN ${latitude} - 1.5 AND ${latitude} + 1.5 
                        AND longitude BETWEEN ${longitude} - 1.5 AND ${longitude} + 1.5 
                        ORDER BY ( 
                            (${latitude} - latitude) * (${latitude} - latitude) + (${longitude} - longitude) * (${longitude} - longitude) * ${scale} 
                        ) ASC 
                        LIMIT 1
                    );`;

            // Prepare a statement
            let stmt = db.exec(query);
          
            var response= {};
            for(var i=0; i< stmt[0].values[0].length; i++){
                response[stmt[0].columns[i]] = stmt[0].values[0][i];
            }
            return response;
        }
        
        function processLayer(current_layer){
            var counter = 1;
            var once = false;
                    
            current_layer.eachLayer(function(layer) {
                    layer.feature.properties.id = counter++;
                    
                    var date_year = layer.feature.properties.name.substring(0, 4);
                    var date_month = layer.feature.properties.name.substring(4, 6);
                    var date_day = layer.feature.properties.name.substring(6, 8);
                    var username = layer.feature.properties.name.substring(8, layer.feature.properties.name.length);
                    
                    layer.feature.properties.year = date_year;
                    layer.feature.properties.month = date_month;
                    layer.feature.properties.day = date_day;
                    layer.feature.properties.username = username;
                    
                    try{
                        var res = layer.feature.properties.descriptio.split(",");
                        var gender = res[0];
                        var number_of_people  = res[1];
                        var remainder = res.slice(2, res.length)
                        var rest_of_description = String(remainder.join());
                        var has_mask = rest_of_description.toLowerCase().includes("mask");
                        
                        layer.feature.properties.gender = gender;
                        layer.feature.properties.number_of_people = number_of_people;
                        layer.feature.properties.has_mask = has_mask;
                        layer.feature.properties.description = rest_of_description;
                    }catch(err){}
                    
                        
                    try{
                        layer.feature.coordinates
                        var lng = layer.feature.geometry.coordinates[0][0];
                        var lat = layer.feature.geometry.coordinates[0][1]
                        
                        var response = simpleReverseGeocoding(lng,lat);
                            
                        layer.feature.properties.country = response.country_name;
                        layer.feature.properties.state_district = response.admin1_name;
                        layer.feature.properties.country_code = response.country_id;
                    }catch(err){}
                    
                    if(once){
                        console.log(layer.feature);
                        once = false;
                    }
            });
            return current_layer;
        }
        
        function loadData(url){     
            var current_layer = omnivore.kml(url, null, customLayer)
            .on('ready', function() {
                console.log(url," data loaded");
                current_layer = processLayer(current_layer);
                geojson_layer = current_layer.toGeoJSON();
                
                createOverlays(geojson_layer);
                //createSearch(geojson_layer,options,search_categories);
            })
            .on('error', function() {
                // fired if the layer can't be loaded over AJAX or can't be parsed
                console.log("Error loading ", url ," data");
            });
        };
        
        async function createSearch(layer,options,search_categories){
            var poiLayers = L.layerGroup([]);
            
            for (var key in overlays){
              //console.log( key, overlays[key] );
              poiLayers.addLayer(overlays[key]);
            }
            
            poiLayers.addTo(mymap);
        
            var fuseOptions = {
              shouldSort: true,
              tokenize: true,
              threshold: 0.5,
              location: 0,
              maxPatternLength: 32,
              minMatchCharLength: 2,
              keys: search_categories
            };
        
            var fuse = new Fuse(layer.features, fuseOptions);
        
            searchCtrl = L.control.search({
                   initial: false,
                   layer: poiLayers,
                   collapsed: false,
                   casesensitive: false,
                   propertyName: 'name',
                   container: 'findbox',
                   filterData: function(text, records) {
                    var jsons = fuse.search(text),
                        ret = {}, key;
                    
                    for(var i in jsons) {
                        key = jsons[i].properties.name;
                        ret[ key ]= records[key];
                    }

                    console.log(jsons,ret);
                    return ret;
                }
            })
            .on('search:locationfound', function(e) {
                e.layer.openPopup();
            });
            
            mymap.addControl(searchCtrl);
        
            /*
            searchCtrl = L.control.fuseSearch(options);
            mymap.addControl(searchCtrl);
            console.log(layer.features);
            console.log(search_categories);
            searchCtrl.indexFeatures(layer.features, search_categories);
            */
        };
        
        var prevLayerClicked = null;
        
        function highlightFeature(e) {
            var layer = e.target;

            layer.setStyle({
                weight: 5,
                color: '#666',
                dashArray: '',
                fillOpacity: 0.7
            });

            if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                layer.bringToFront();
            }
            
            info.update(layer.feature);
        }
        
        function resetHighlight(e) {
            var layer = e.target;
            layer.setStyle(style(layer.feature));
            info.update();
        }
        
        function mybindPopup(feature, layer){
            layer.on({
                mouseover: highlightFeature,
                mouseout: resetHighlight,
                click: function(e){
                    if (prevLayerClicked !== null) {
                      // Reset style
                        prevLayerClicked.setStyle({
                            weight: 2,
                            opacity: 1,
                            color: 'red',
                            dashArray: '',
                            fillOpacity: 1.9,
                            fillColor: 'red'
                        });
                    }
                    mymap.fitBounds(e.target.getBounds());
                    var layer = e.target;
                    layer.setStyle({
                        weight: 5,
                        color: 'blue',
                        dashArray: '',
                        fillOpacity: 0.9,
                        fillColor: 'blue'
                    });
                    if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                        layer.bringToFront();
                    }
                    //info.update(layer.feature.properties.availability);
                    prevLayerClicked = layer;
                }
            });
        };
        
        function createOverlays(geojson_layer){
                // Iterate the collection
                geojson_layer.features.forEach(function (feature) {

                  var category = feature.properties.state_district;
                  var username = feature.properties.username;

                  categories.add(category);

                  // Check if there's already an overlay for this category
                  if (!overlays[category]) {

                    // Create and store new layer in overlays object
                    overlays[category] = new L.GeoJSON(null, {
                      'onEachFeature': mybindPopup,
                      'style': style,
                      'filter':function (geoJsonFeature) {
                            return true;
                       }
                    });

                    // Add layer/title to control
                    //controlLayers.addOverlay(overlays[category], category); 
                  }

                  // Add feature to corresponding layer
                  overlays[category].addData(feature);
                });
                
                var locations = {
                    label: 'Locations',
                    selectAllCheckbox: true,
                    children: [
                    ]
                };
                
                var baseTree = {
                    label: 'Base Layers',
                    children: [
                        {
                            label: 'World &#x1f5fa;',
                            children: [
                                { label: 'OpenStreetMap', layer: osm },
                                /* ... */
                            ]
                        }
                    ]
                };
                
                for (var it = categories.values(), val= null; val=it.next().value; ) {
                    var a = [];
                    overlays[val].eachLayer(function (layer) {
                        a.push({'label':layer.feature.properties.username, layer: layer});
                    });
                    locations.children.push({
                        'label':val,
                        collapsed:true,
                        selectAllCheckbox: true,
                        children: a
                    });
                }
                
                ctl = L.control.layers.tree(baseTree, locations,
                {
                    namedToggle: true,
                    collapseAll: 'Collapse all',
                    expandAll: 'Expand all',
                    collapsed: false,
                });
                
                mymap.addControl(ctl);
                /*
                mymap.on('layeradd layerremove', function () {
                    // Create new empty bounds
                    var bounds = new L.LatLngBounds();
                    // Iterate the map's layers
                    mymap.eachLayer(function (layer) {
                        // Check if layer is a featuregroup
                        if (layer instanceof L.FeatureGroup) {
                            // Extend bounds with group's bounds
                            bounds.extend(layer.getBounds());
                        }
                    });
                    // Check if bounds are valid (could be empty)
                    if (bounds.isValid()) {
                        // Valid, fit bounds
                        mymap.fitBounds(bounds);
                    } else {
                        // Invalid, fit world
                        mymap.fitWorld();
                    }
                });
                */
        };
        
        (async () => {
            try {
                main();
            } catch (e) {
                // Deal with the fact the chain failed
            }
        })(); 
    </script>
</body>

</html>
